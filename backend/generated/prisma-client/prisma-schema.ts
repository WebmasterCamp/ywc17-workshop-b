// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateChat {
  count: Int!
}

type AggregateParty {
  count: Int!
}

type AggregatePromotion {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Chat {
  id: ID!
  owner: User!
  message: String!
  party: Party!
}

type ChatConnection {
  pageInfo: PageInfo!
  edges: [ChatEdge]!
  aggregate: AggregateChat!
}

input ChatCreateInput {
  id: ID
  owner: UserCreateOneInput!
  message: String!
  party: PartyCreateOneWithoutMessagesInput!
}

input ChatCreateManyWithoutPartyInput {
  create: [ChatCreateWithoutPartyInput!]
  connect: [ChatWhereUniqueInput!]
}

input ChatCreateWithoutPartyInput {
  id: ID
  owner: UserCreateOneInput!
  message: String!
}

type ChatEdge {
  node: Chat!
  cursor: String!
}

enum ChatOrderByInput {
  id_ASC
  id_DESC
  message_ASC
  message_DESC
}

type ChatPreviousValues {
  id: ID!
  message: String!
}

input ChatScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  AND: [ChatScalarWhereInput!]
  OR: [ChatScalarWhereInput!]
  NOT: [ChatScalarWhereInput!]
}

type ChatSubscriptionPayload {
  mutation: MutationType!
  node: Chat
  updatedFields: [String!]
  previousValues: ChatPreviousValues
}

input ChatSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ChatWhereInput
  AND: [ChatSubscriptionWhereInput!]
  OR: [ChatSubscriptionWhereInput!]
  NOT: [ChatSubscriptionWhereInput!]
}

input ChatUpdateInput {
  owner: UserUpdateOneRequiredInput
  message: String
  party: PartyUpdateOneRequiredWithoutMessagesInput
}

input ChatUpdateManyDataInput {
  message: String
}

input ChatUpdateManyMutationInput {
  message: String
}

input ChatUpdateManyWithoutPartyInput {
  create: [ChatCreateWithoutPartyInput!]
  delete: [ChatWhereUniqueInput!]
  connect: [ChatWhereUniqueInput!]
  set: [ChatWhereUniqueInput!]
  disconnect: [ChatWhereUniqueInput!]
  update: [ChatUpdateWithWhereUniqueWithoutPartyInput!]
  upsert: [ChatUpsertWithWhereUniqueWithoutPartyInput!]
  deleteMany: [ChatScalarWhereInput!]
  updateMany: [ChatUpdateManyWithWhereNestedInput!]
}

input ChatUpdateManyWithWhereNestedInput {
  where: ChatScalarWhereInput!
  data: ChatUpdateManyDataInput!
}

input ChatUpdateWithoutPartyDataInput {
  owner: UserUpdateOneRequiredInput
  message: String
}

input ChatUpdateWithWhereUniqueWithoutPartyInput {
  where: ChatWhereUniqueInput!
  data: ChatUpdateWithoutPartyDataInput!
}

input ChatUpsertWithWhereUniqueWithoutPartyInput {
  where: ChatWhereUniqueInput!
  update: ChatUpdateWithoutPartyDataInput!
  create: ChatCreateWithoutPartyInput!
}

input ChatWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  owner: UserWhereInput
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  party: PartyWhereInput
  AND: [ChatWhereInput!]
  OR: [ChatWhereInput!]
  NOT: [ChatWhereInput!]
}

input ChatWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createChat(data: ChatCreateInput!): Chat!
  updateChat(data: ChatUpdateInput!, where: ChatWhereUniqueInput!): Chat
  updateManyChats(data: ChatUpdateManyMutationInput!, where: ChatWhereInput): BatchPayload!
  upsertChat(where: ChatWhereUniqueInput!, create: ChatCreateInput!, update: ChatUpdateInput!): Chat!
  deleteChat(where: ChatWhereUniqueInput!): Chat
  deleteManyChats(where: ChatWhereInput): BatchPayload!
  createParty(data: PartyCreateInput!): Party!
  updateParty(data: PartyUpdateInput!, where: PartyWhereUniqueInput!): Party
  upsertParty(where: PartyWhereUniqueInput!, create: PartyCreateInput!, update: PartyUpdateInput!): Party!
  deleteParty(where: PartyWhereUniqueInput!): Party
  deleteManyParties(where: PartyWhereInput): BatchPayload!
  createPromotion(data: PromotionCreateInput!): Promotion!
  updatePromotion(data: PromotionUpdateInput!, where: PromotionWhereUniqueInput!): Promotion
  updateManyPromotions(data: PromotionUpdateManyMutationInput!, where: PromotionWhereInput): BatchPayload!
  upsertPromotion(where: PromotionWhereUniqueInput!, create: PromotionCreateInput!, update: PromotionUpdateInput!): Promotion!
  deletePromotion(where: PromotionWhereUniqueInput!): Promotion
  deleteManyPromotions(where: PromotionWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Party {
  id: ID!
  member: User
  messages(where: ChatWhereInput, orderBy: ChatOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Chat!]
  confirmedMember: User
}

type PartyConnection {
  pageInfo: PageInfo!
  edges: [PartyEdge]!
  aggregate: AggregateParty!
}

input PartyCreateInput {
  id: ID
  member: UserCreateOneWithoutPartyInput
  messages: ChatCreateManyWithoutPartyInput
  confirmedMember: UserCreateOneInput
}

input PartyCreateOneWithoutMemberInput {
  create: PartyCreateWithoutMemberInput
  connect: PartyWhereUniqueInput
}

input PartyCreateOneWithoutMessagesInput {
  create: PartyCreateWithoutMessagesInput
  connect: PartyWhereUniqueInput
}

input PartyCreateWithoutMemberInput {
  id: ID
  messages: ChatCreateManyWithoutPartyInput
  confirmedMember: UserCreateOneInput
}

input PartyCreateWithoutMessagesInput {
  id: ID
  member: UserCreateOneWithoutPartyInput
  confirmedMember: UserCreateOneInput
}

type PartyEdge {
  node: Party!
  cursor: String!
}

enum PartyOrderByInput {
  id_ASC
  id_DESC
}

type PartyPreviousValues {
  id: ID!
}

type PartySubscriptionPayload {
  mutation: MutationType!
  node: Party
  updatedFields: [String!]
  previousValues: PartyPreviousValues
}

input PartySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PartyWhereInput
  AND: [PartySubscriptionWhereInput!]
  OR: [PartySubscriptionWhereInput!]
  NOT: [PartySubscriptionWhereInput!]
}

input PartyUpdateInput {
  member: UserUpdateOneWithoutPartyInput
  messages: ChatUpdateManyWithoutPartyInput
  confirmedMember: UserUpdateOneInput
}

input PartyUpdateOneRequiredWithoutMessagesInput {
  create: PartyCreateWithoutMessagesInput
  update: PartyUpdateWithoutMessagesDataInput
  upsert: PartyUpsertWithoutMessagesInput
  connect: PartyWhereUniqueInput
}

input PartyUpdateOneWithoutMemberInput {
  create: PartyCreateWithoutMemberInput
  update: PartyUpdateWithoutMemberDataInput
  upsert: PartyUpsertWithoutMemberInput
  delete: Boolean
  disconnect: Boolean
  connect: PartyWhereUniqueInput
}

input PartyUpdateWithoutMemberDataInput {
  messages: ChatUpdateManyWithoutPartyInput
  confirmedMember: UserUpdateOneInput
}

input PartyUpdateWithoutMessagesDataInput {
  member: UserUpdateOneWithoutPartyInput
  confirmedMember: UserUpdateOneInput
}

input PartyUpsertWithoutMemberInput {
  update: PartyUpdateWithoutMemberDataInput!
  create: PartyCreateWithoutMemberInput!
}

input PartyUpsertWithoutMessagesInput {
  update: PartyUpdateWithoutMessagesDataInput!
  create: PartyCreateWithoutMessagesInput!
}

input PartyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  member: UserWhereInput
  messages_every: ChatWhereInput
  messages_some: ChatWhereInput
  messages_none: ChatWhereInput
  confirmedMember: UserWhereInput
  AND: [PartyWhereInput!]
  OR: [PartyWhereInput!]
  NOT: [PartyWhereInput!]
}

input PartyWhereUniqueInput {
  id: ID
}

type Promotion {
  id: ID!
  title: String!
  coverImageUrl: String
  description: String!
  duration: String
  location: String
  additionalInfo: String
  condition: String
  contact: String
}

type PromotionConnection {
  pageInfo: PageInfo!
  edges: [PromotionEdge]!
  aggregate: AggregatePromotion!
}

input PromotionCreateInput {
  id: ID
  title: String!
  coverImageUrl: String
  description: String!
  duration: String
  location: String
  additionalInfo: String
  condition: String
  contact: String
}

type PromotionEdge {
  node: Promotion!
  cursor: String!
}

enum PromotionOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  coverImageUrl_ASC
  coverImageUrl_DESC
  description_ASC
  description_DESC
  duration_ASC
  duration_DESC
  location_ASC
  location_DESC
  additionalInfo_ASC
  additionalInfo_DESC
  condition_ASC
  condition_DESC
  contact_ASC
  contact_DESC
}

type PromotionPreviousValues {
  id: ID!
  title: String!
  coverImageUrl: String
  description: String!
  duration: String
  location: String
  additionalInfo: String
  condition: String
  contact: String
}

type PromotionSubscriptionPayload {
  mutation: MutationType!
  node: Promotion
  updatedFields: [String!]
  previousValues: PromotionPreviousValues
}

input PromotionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PromotionWhereInput
  AND: [PromotionSubscriptionWhereInput!]
  OR: [PromotionSubscriptionWhereInput!]
  NOT: [PromotionSubscriptionWhereInput!]
}

input PromotionUpdateInput {
  title: String
  coverImageUrl: String
  description: String
  duration: String
  location: String
  additionalInfo: String
  condition: String
  contact: String
}

input PromotionUpdateManyMutationInput {
  title: String
  coverImageUrl: String
  description: String
  duration: String
  location: String
  additionalInfo: String
  condition: String
  contact: String
}

input PromotionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  coverImageUrl: String
  coverImageUrl_not: String
  coverImageUrl_in: [String!]
  coverImageUrl_not_in: [String!]
  coverImageUrl_lt: String
  coverImageUrl_lte: String
  coverImageUrl_gt: String
  coverImageUrl_gte: String
  coverImageUrl_contains: String
  coverImageUrl_not_contains: String
  coverImageUrl_starts_with: String
  coverImageUrl_not_starts_with: String
  coverImageUrl_ends_with: String
  coverImageUrl_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  duration: String
  duration_not: String
  duration_in: [String!]
  duration_not_in: [String!]
  duration_lt: String
  duration_lte: String
  duration_gt: String
  duration_gte: String
  duration_contains: String
  duration_not_contains: String
  duration_starts_with: String
  duration_not_starts_with: String
  duration_ends_with: String
  duration_not_ends_with: String
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  additionalInfo: String
  additionalInfo_not: String
  additionalInfo_in: [String!]
  additionalInfo_not_in: [String!]
  additionalInfo_lt: String
  additionalInfo_lte: String
  additionalInfo_gt: String
  additionalInfo_gte: String
  additionalInfo_contains: String
  additionalInfo_not_contains: String
  additionalInfo_starts_with: String
  additionalInfo_not_starts_with: String
  additionalInfo_ends_with: String
  additionalInfo_not_ends_with: String
  condition: String
  condition_not: String
  condition_in: [String!]
  condition_not_in: [String!]
  condition_lt: String
  condition_lte: String
  condition_gt: String
  condition_gte: String
  condition_contains: String
  condition_not_contains: String
  condition_starts_with: String
  condition_not_starts_with: String
  condition_ends_with: String
  condition_not_ends_with: String
  contact: String
  contact_not: String
  contact_in: [String!]
  contact_not_in: [String!]
  contact_lt: String
  contact_lte: String
  contact_gt: String
  contact_gte: String
  contact_contains: String
  contact_not_contains: String
  contact_starts_with: String
  contact_not_starts_with: String
  contact_ends_with: String
  contact_not_ends_with: String
  AND: [PromotionWhereInput!]
  OR: [PromotionWhereInput!]
  NOT: [PromotionWhereInput!]
}

input PromotionWhereUniqueInput {
  id: ID
}

type Query {
  chat(where: ChatWhereUniqueInput!): Chat
  chats(where: ChatWhereInput, orderBy: ChatOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Chat]!
  chatsConnection(where: ChatWhereInput, orderBy: ChatOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ChatConnection!
  party(where: PartyWhereUniqueInput!): Party
  parties(where: PartyWhereInput, orderBy: PartyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Party]!
  partiesConnection(where: PartyWhereInput, orderBy: PartyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PartyConnection!
  promotion(where: PromotionWhereUniqueInput!): Promotion
  promotions(where: PromotionWhereInput, orderBy: PromotionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Promotion]!
  promotionsConnection(where: PromotionWhereInput, orderBy: PromotionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PromotionConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Subscription {
  chat(where: ChatSubscriptionWhereInput): ChatSubscriptionPayload
  party(where: PartySubscriptionWhereInput): PartySubscriptionPayload
  promotion(where: PromotionSubscriptionWhereInput): PromotionSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  name: String!
  profileImageUrl: String
  party: Party
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String!
  profileImageUrl: String
  party: PartyCreateOneWithoutMemberInput
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutPartyInput {
  create: UserCreateWithoutPartyInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutPartyInput {
  id: ID
  name: String!
  profileImageUrl: String
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  profileImageUrl_ASC
  profileImageUrl_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
  profileImageUrl: String
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  name: String
  profileImageUrl: String
  party: PartyUpdateOneWithoutMemberInput
}

input UserUpdateInput {
  name: String
  profileImageUrl: String
  party: PartyUpdateOneWithoutMemberInput
}

input UserUpdateManyMutationInput {
  name: String
  profileImageUrl: String
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutPartyInput {
  create: UserCreateWithoutPartyInput
  update: UserUpdateWithoutPartyDataInput
  upsert: UserUpsertWithoutPartyInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutPartyDataInput {
  name: String
  profileImageUrl: String
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutPartyInput {
  update: UserUpdateWithoutPartyDataInput!
  create: UserCreateWithoutPartyInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  profileImageUrl: String
  profileImageUrl_not: String
  profileImageUrl_in: [String!]
  profileImageUrl_not_in: [String!]
  profileImageUrl_lt: String
  profileImageUrl_lte: String
  profileImageUrl_gt: String
  profileImageUrl_gte: String
  profileImageUrl_contains: String
  profileImageUrl_not_contains: String
  profileImageUrl_starts_with: String
  profileImageUrl_not_starts_with: String
  profileImageUrl_ends_with: String
  profileImageUrl_not_ends_with: String
  party: PartyWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
}
`